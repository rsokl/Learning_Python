{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Variables & Assignment\n",
    "\n",
    "<div class=\"alert alert-warning\">\n",
    "\n",
    "**Note**: \n",
    "\n",
    "There are reading-comprehension exercises included throughout the text. These are meant to help you put your reading to practice. Solutions for the exercises are included at the bottom of this page.\n",
    "</div>\n",
    "\n",
    "\n",
    "Variables permit us to write code that is flexible and amendable to repurpose. Suppose we want write code that logs a student's grade on an exam. The logic behind this process should not depend on whether we are logging Brian's score of 92% versus Ashley's score of 94%. As such, we can utilize variables, say `name` and `grade`, to serve as placeholders for this information. In this subsection, we will demonstrate how to define variables in Python.\n",
    "\n",
    "In Python, the `=` symbol represents the \"assignment\" operator. The variable goes to the left of `=`, and the object that the variable is being assigned to goes to the right:\n",
    "```python\n",
    "name = \"Brian\"  # the variable `name` is being assigned to the string \"Brian\"\n",
    "grade = 92      # the variable `grade` is being assigned to the integer 92\n",
    "```\n",
    "Attempting to reverse the assignment order (e.g. `92 = name`) will result in a syntax error.  When a variable is assigned to an object (like a number or a string), it is common to say that the variable **references** that object. That is, the variable `name` references the string `\"Brian\"`.\n",
    "\n",
    "Once a variable is referencing a value, you can use the variable elsewhere in your code as a placeholder:\n",
    "```python\n",
    "# demonstrating the use of variables in code\n",
    "name = \"Brian\"\n",
    "grade = 92\n",
    "failing = False\n",
    "\n",
    "if grade < 60:\n",
    "    failing = True\n",
    "\n",
    "# writes: name | grade | passing-status\n",
    "# to the end of the file \"student_grades.txt\"\n",
    "with open(\"student_grades.txt\", mode=\"a\") as opened_file:\n",
    "    opened_file.write(f\"{name} | {grade} | {failing}\")\n",
    "```\n",
    "\n",
    "## Valid Names for Variables\n",
    "A variable name can only consist of alphanumeric characters (`a-z`, `A-Z`, `0-9`) and the underscore symbol (`_`); a valid name cannot begin with a numerical value:\n",
    "\n",
    "- `var`: valid\n",
    "- `_var2`: valid\n",
    "- `ApplePie_Yum_Yum`: valid\n",
    "- `2cool`: **invalid** (begins with a numerical character)\n",
    "- `I.am.the.best`: **invalid** (contains `.`)\n",
    "\n",
    "They also cannot conflict with character sequences that are reserved by the Python language. As such, the following cannot be used as variable names:\n",
    "\n",
    "- for, while, break, pass, continue\n",
    "- in, is, not\n",
    "- if, else, elif\n",
    "- def, class, return, yield, raises\n",
    "- import, from, as, with\n",
    "- try, except, finally"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Referencing a Mutable Object with Multiple Variables\n",
    "It is possible to assign variables to other, existing variables. Doing so will cause the variables to reference the same object:\n",
    "```python\n",
    "# demonstrating the behavior of variables \n",
    "# referencing the same object\n",
    ">>> list1 = [1, 2, 3]  #  `list1` references [1, 2, 3]\n",
    ">>> list2 = list1      #  `list2` and `list1` now both reference [1, 2, 3]\n",
    "\n",
    ">>> print(list1)\n",
    "[1, 2, 3]\n",
    "\n",
    ">>> print(list2)\n",
    "[1, 2, 3]\n",
    "```\n",
    "\n",
    "What this entails is that these common variables will reference the *same instance* of the list. Meaning that if the list changes, all of the variables referencing that list will reflect this change:\n",
    "\n",
    "```python\n",
    ">>> list1.append(4)  # append 4 to the end of [1, 2, 3]\n",
    ">>> print(list1)\n",
    "[1, 2, 3, 4]\n",
    "```\n",
    "\n",
    "We can see that `list2` is still assigned to reference the *same, updated* list as `list1`:\n",
    "```python\n",
    ">>> print(list2)\n",
    "[1, 2, 3, 4]\n",
    "```\n",
    "In general, assigning a variable `b` to a variable `a` will cause the variables to reference the *same* object in the system's memory, and assigning `c` to `a` or `b` will simply have a third variable reference this same object. Then any change (a.k.a *mutation*)  of the object will be reflected in all of the variables that reference it (`a`, `b`, and `c`).\n",
    "\n",
    "Of course, assigning two variables to identical, but *distinct* lists means that a change to one list will not affect the other:\n",
    "\n",
    "```python\n",
    ">>> list1 = [1, 2, 3]  #  `list1` references [1, 2, 3]\n",
    ">>> list2 = [1, 2, 3]  #  `list2` references a *separate* list, whose value is [1, 2, 3]\n",
    "\n",
    ">>> list1.append(4)  # append 4 to the end of [1, 2, 3]\n",
    ">>> print(list1)\n",
    "[1, 2, 3, 4]\n",
    "\n",
    ">>> print(list2)     # `list2` still references its own list\n",
    "[1, 2, 3]\n",
    "``` "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***\n",
    "\n",
    "**Reading Comprehension: Does slicing a list produce a reference to that list?**\n",
    "\n",
    "Suppose `x` is assigned to a list, and that `y` is assigned to a \"slice\" of `x`. Do `x` and `y` reference the same list? That is, if you update part of the subsequence common to `x` and `y`, does that change show up in both of them? Write some simple code to investigate this. \n",
    "\n",
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This discussion is warranted for a list, because a list is *mutable* - a given list can be changed after it is created. A tuple, being *immutable*, cannot be changed. Any operation that appears to be updating a tuple must actually be creating an entirely new tuple altogether. Consider the following example:\n",
    "```python\n",
    "# `x` and `y` reference the same tuple \n",
    ">>> x = (1, 2, 3)\n",
    ">>> y = x\n",
    "\n",
    "# shorthand for: x = x + (4, 5)\n",
    "# this creates a new tuple\n",
    ">>> x += (4, 5)\n",
    "(1, 2, 3, 4, 5)\n",
    "\n",
    "# y still references the original tuple\n",
    ">>> y\n",
    "(1, 2, 3)\n",
    "```\n",
    "## Mutable & Immutable Types of Objects\n",
    "The following are some common immutable and mutable objects in Python. These will be important to have in mind as we start to work with dictionaries and sets. \n",
    "\n",
    "\n",
    "**Some immutable objects**\n",
    "\n",
    " - numbers (integers, floating-point numbers, complex numbers)\n",
    " - strings\n",
    " - tuples \n",
    " - boolean values\n",
    " - \"frozen\"-sets\n",
    "\n",
    "**Some mutable objects**\n",
    "\n",
    " - lists\n",
    " - dictionaries\n",
    " - sets\n",
    " - numpy-arrays"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***\n",
    "\n",
    "**Reading Comprehension: Understanding References**\n",
    "\n",
    "Based on our discussion of mutable and immutable objects, predict what the value of `y` will be in the following circumstance:\n",
    "\n",
    "```python\n",
    ">>> x = 3\n",
    ">>> y = x\n",
    "\n",
    "# shorthand for: `x = x * 3`\n",
    ">>> x *= 3\n",
    ">>>x\n",
    "9\n",
    "\n",
    ">>> y\n",
    "???\n",
    "```\n",
    "\n",
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***\n",
    "\n",
    "## Reading Comprehension Exercise Solutions:\n",
    "**Does slicing a list produce a reference to that list?: Solution**\n",
    "\n",
    "Based on the following behavior, we can conclude that slicing a list does **not** produce a reference to the original list. Rather, slicing a list produces a copy of the appropriate subsequence of the list:\n",
    "```python\n",
    ">>> x = [0, 1, 2, 3]\n",
    "\n",
    ">>> y = x[:2] \n",
    ">>> y      # does `y` reference the same list as `x`?\n",
    "[0, 1]\n",
    "\n",
    "x[0] = -1  # update one of the entries of the list that `x` references\n",
    ">>> x\n",
    "[-1, 1, 2, 3]\n",
    "\n",
    ">>> y      # the list that `y` references was unaffected by the update\n",
    "[0, 1]\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Understanding References: Solutions**\n",
    "\n",
    "Integers are immutable, thus `x` must reference an entirely new object (`9`), and `y` still references `3`."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
