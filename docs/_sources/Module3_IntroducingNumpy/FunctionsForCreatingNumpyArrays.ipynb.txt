{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Functions for Creating NumPy Arrays \n",
    "This section presents standard methods for creating NumPy arrays of varying shapes and contents. NumPy provides a laundry list of functions for creating arrays\n",
    "\n",
    "## Creating Arrays from Python Sequences\n",
    "You can create an array from a Python `list` or `tuple` by using NumPy's `array` function. NumPy will interpret the structure of the data it receives to determine the dimensionality and shape of the array. For example, a single list of numbers will be used to create a 1-dimensional array: \n",
    "\n",
    "```python\n",
    ">>> import numpy as np\n",
    "# a list of numbers will become a 1D-array\n",
    ">>> np.array([1., 2., 3.])  # shape: (3,)\n",
    "array([ 1.,  2.,  3.])\n",
    "```\n",
    "\n",
    "Nested lists/tuples will be used to constructing multidimensional arrays. For example, a \"list of equal-length lists of numbers\" will lead to a 2-dimensional array; each of the inner-lists comprises a row of the array. Thus a list of two, length-three lists will produce a (2,3)-shaped array:\n",
    " \n",
    "```python\n",
    "# lists of lists of numbers will produce a 2D-array\n",
    ">>> np.array([[1., 2., 3.], [4., 5., 6.]])  # shape: (2, 3)\n",
    "array([[ 1.,  2.,  3.],\n",
    "       [ 4.,  5.,  6.]])\n",
    "```\n",
    "\n",
    "A \"list of equal-length lists, of equal-length lists of numbers\" creates a 3D-array, and so on. Recall that using repeated concatenation, `[0]*3` will produce `[0, 0, 0]`. Using this, let's create two lists, each containing three lists, each containing four zeros; feeding this to `np.array` thus produces a 2x3x4 array of zeros:\n",
    "```python\n",
    "# A list of lists of lists of zeros creates a 3D-array\n",
    ">>> np.array([[[0]*4]*3]*2)\n",
    "array([[[0, 0, 0, 0],\n",
    "        [0, 0, 0, 0],\n",
    "        [0, 0, 0, 0]],\n",
    "\n",
    "       [[0, 0, 0, 0],\n",
    "        [0, 0, 0, 0],\n",
    "        [0, 0, 0, 0]]])\n",
    "```\n",
    "\n",
    "You will seldom use lists to form high-dimensional arrays like this. Instead, there are other array-creation functions that are more amendable to generating high-dimensional data, which we will introduce next. For example, we will see that the `np.zeros` function is a much more civilized way to create a high-dimensional array of zeros. \n",
    "\n",
    "\n",
    "<div class=\"alert alert-warning\"> \n",
    "\n",
    "**Warning!** \n",
    "\n",
    "You actually *can* create an array from lists of *unequal* lengths. The resulting array is **not** an ND-array as it has no well-defined dimensionality. Instead, something called an *object-array* is produced, which does not benefit from the majoriyy of NumPy's features. This is a relatively obscure feature of the NumPy library, and should be avoided unless you really know what you're doing!\n",
    "\n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Creating Constant Arrays: `zeros` and `ones`\n",
    "NumPy provides the functions `zeros` and `ones`, which will fill an array of user-specified shape with the 0s and 1s, respectively:\n",
    "\n",
    "```python\n",
    "# create a 3x4 array of zeros\n",
    ">>> np.zeros((3, 4))\n",
    "array([[ 0.,  0.,  0.,  0.],\n",
    "       [ 0.,  0.,  0.,  0.],\n",
    "       [ 0.,  0.,  0.,  0.]])\n",
    "\n",
    "# create a shape-(4,) array of ones\n",
    ">>> np.ones((4,))\n",
    "array([ 1.,  1.,  1.,  1.])\n",
    "```\n",
    "\n",
    "NumPy provides additional functions for creating constant-valued arrays. Please refer to [the official documentation](https://docs.scipy.org/doc/numpy/reference/routines.array-creation.html#ones-and-zeros) for a complete listing. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Creating Sequential Arrays: `arange` and `linspace`\n",
    "The [arange](https://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html#numpy.arange) function allows you to initialize a sequence of integers based on a starting point (inclusive), stopping point (exclusive), and step size. This is very similar to the `range` function, however `arange` immediately creates this sequence as an array, whereas `range` produces a generator.\n",
    "```python\n",
    ">>> np.arange(0, 10, 1)  # start (included): 0, stop (excluded): 10, step:1 \n",
    "array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n",
    "\n",
    "# supplying one value to `arange` amounts to specifying the stop value \n",
    "# start=0 and step=1 are then used a defaults\n",
    ">>> np.arange(10)  # equivalent to: start: 0, stop: 10, step:1 \n",
    "array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n",
    "\n",
    ">>> np.arange(-5, 6, 2) # start (included): -5, stop (excluded): 6, step:2 \n",
    "array([-5, -3, -1,  1,  3,  5])\n",
    "```\n",
    "\n",
    "The [linspace](https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.linspace.html) function allows you to generate $N$ *evenly-spaced* points within a user-specified interval $[i, j]$ ($i$ and $j$ are included in the interval). This is often used to generate a domain of values on which to evaluate a mathematical function (e.g. if you want to the sine function from $-\\pi$ to $\\pi$ on a finely-divided grid).\n",
    "\n",
    "```python\n",
    "# generate five evenly-spaced points on the interval [-1, 1]\n",
    ">>> np.linspace(-1, 1, 5)\n",
    "array([-1. , -0.5,  0. ,  0.5,  1. ])\n",
    "\n",
    "# generate two evenly-spaced points on the interval [3, 4]\n",
    ">>> np.linspace(3, 4, 2)\n",
    "array([ 3.,  4.])\n",
    "\n",
    "# generate 100 evenly-spaced points on the interval [-pi, pi]\n",
    ">>> np.linspace(-np.pi, np.pi, 100)\n",
    "array([-3.14159265, ..., 3.14159265])\n",
    "```\n",
    "\n",
    "Numpy has other functions for creating sequential arrays, such as producing an array spaced evenly on a log-scaled interval. See the [official documentation](https://docs.scipy.org/doc/numpy/reference/routines.array-creation.html#numerical-ranges) for a complete listing."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Creating Arrays Using Random Sampling\n",
    "Several functions can be accessed from `np.random`, which populate arrays of a user-specified shape by drawing randomly from a specified statistical distribution:\n",
    "```python\n",
    "# create a shape-(3,3) array by drawing its entries randomly\n",
    "# from the uniform distribution [0, 1) \n",
    ">>> np.random.rand(3,3)\n",
    "array([[ 0.09542611,  0.13183498,  0.39836068],\n",
    "       [ 0.7358235 ,  0.77640024,  0.74913595],\n",
    "       [ 0.37702688,  0.86617624,  0.39846429]])\n",
    "\n",
    "# create a shape-(5,) array by drawing its entries randomly\n",
    "# from a mean-0, variance-1 normal (a.k.a Gaussian) distribution\n",
    ">>> np.random.randn(5)\n",
    "array([-1.11262121, -0.35392007,  0.4245215 , -0.81995588,  0.65412323])\n",
    "```\n",
    "There are [many more functions](https://docs.scipy.org/doc/numpy/reference/routines.random.html#distributions) to read about that allow you to draw from a wide variety of statistical distributions. This only scratches the surface of random number generation in NumPy.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Creating an Array with a Specified Data Type\n",
    "Each of the preceding functions used to create an array can be passed a so-called 'keyword' argument, `dtype`, which instructs NumPy to use a specified data type when producing the contents of the array.\n",
    "\n",
    "```python\n",
    "# populate an array using 32-bit floating point numbers\n",
    ">>> np.array([1, 2, 3], dtype=\"float32\") \n",
    "array([ 1.,  2.,  3.], dtype=float32)\n",
    "\n",
    "# default data type produced by `arange` is 32-bit integers\n",
    ">>> np.arange(0, 4).dtype  \n",
    "dtype('int32')\n",
    "\n",
    "# the data type produced by `arange` can be specified otherwise\n",
    ">>> np.arange(0, 4, dtype=\"float16\")\n",
    "array([ 0.,  1.,  2.,  3.], dtype=float16)\n",
    "\n",
    "# generate shape-(4,4) array of 64-bit complex-valued 0s\n",
    ">>> np.zeros((4, 4), dtype=\"complex64\")\n",
    "array([[ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n",
    "       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n",
    "       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],\n",
    "       [ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j]], dtype=complex64)\n",
    "```\n",
    "\n",
    "Refer to [the official NumPy documentation](https://docs.scipy.org/doc/numpy/user/basics.types.html#array-types-and-conversions-between-types) for the complete list of available array datatypes."
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
