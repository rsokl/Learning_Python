{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#  Accessing Data Along Multiple Dimensions in an Array\n",
    "In this section, we will: \n",
    "\n",
    " - Define the \"dimensionality\" of an array.\n",
    " - Discuss the usefulness of ND-arrays.\n",
    " - Introduce the indexing and slicing scheme for accessing an multi-dimensional array's contents\n",
    " \n",
    "We will encounter arrays of varying dimensionalities:\n",
    "\n",
    "```python\n",
    "# A 0-D array\n",
    "np.array(8)\n",
    "\n",
    "# A 1-D array\n",
    "np.array([2.3, 0.1, -9.1])\n",
    "\n",
    "# A 2-D array\n",
    "np.array([[93,  95], \n",
    "          [84, 100], \n",
    "          [99,  87]])\n",
    "\n",
    "# A 3-D array\n",
    "np.array([[[0, 1],\n",
    "           [2, 3]],\n",
    "          \n",
    "          [[4, 5],\n",
    "           [6, 7]]])\n",
    "```\n",
    "\n",
    "Similar to Python's sequences, we use 0-based indices and slicing to access the content of an array. However, we must specify an index/slice for *each* dimension of an array:\n",
    "```python\n",
    "# A 3-D array\n",
    ">>> x = np.array([[[0, 1],\n",
    "                   [2, 3]],\n",
    "              \n",
    "                  [[4, 5],\n",
    "                   [6, 7]]])\n",
    "\n",
    "# get: sheet-0, both rows, flip order of columns\n",
    ">>> x[0, :, ::-1]\n",
    "array([[1, 0],\n",
    "       [3, 2]])\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## One-dimensional Arrays\n",
    "Let's being our discussion by constructing a simple ND-array containing three floating point numbers. \n",
    "\n",
    "```python\n",
    "simple_array = np.array([2.3, 0.1, -9.1])\n",
    "```\n",
    "This array supports the same indexing scheme as Python's sequences (lists, tuples, and strings):\n",
    "\n",
    "```\n",
    " +------+------+------+\n",
    " |  2.3 |  0.1 | -9.1 | \n",
    " +------+------+------+\n",
    "     0      1      2  \n",
    "    -3     -2     -1       \n",
    "```\n",
    "The first row of numbers gives the position of the indices 0…3 in the array; the second row gives the corresponding negative indices. The slice from $i$ to $j$ returns an array containing of all numbers between the edges labeled $i$ and $j$, respectively:\n",
    "\n",
    "```python\n",
    ">>> simple_array[0]\n",
    "2.3\n",
    "\n",
    ">>> simple_array[-2]\n",
    "0.1\n",
    "\n",
    ">>> simple_array[1:3]\n",
    "array([ 0.1, -9.1])\n",
    "\n",
    ">>> simple_array[3]\n",
    "IndexError: index 3 is out of bounds for axis 0 with size 3\n",
    "```\n",
    "\n",
    "Given this indexing scheme, only a *one* integer is needed to specify a unique entry in the array. Similarly only *one* slice is needed to uniquely specify a subsequence of entries in the array. For this reason, we say that this is a *1-dimensional array*. In general, the *dimensionality* of an array specifies the number of indices that are required to uniquely specify one of its entries.\n",
    "\n",
    "<div class=\"alert alert-info\"> \n",
    "\n",
    "**Definition**: \n",
    "\n",
    "The **dimensionality** of an array specifies the number of indices that are required to uniquely specify one of its entries. \n",
    "\n",
    "</div>\n",
    "\n",
    "This definition of dimensionality is common far beyond NumPy; one must use three numbers to uniquely specify a point in physical space, which is why it is said that space consists of three dimensions."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Two-dimensional Arrays\n",
    "Before proceeding further down the path of high-dimensional arrays, let's briefly consider a very simple dataset where the desire to access the data along multiple dimensions is manifestly desirable. Consider the following table from a gradebook:\n",
    "\n",
    "\n",
    "|         | Exam 1 (%)           | Exam 2 (%) |\n",
    "| ------------- |:-------------:| -----:|\n",
    "| Ashley     | $93$ | $95$ |\n",
    "| Brad     | $84$      |   $100$ |\n",
    "| Cassie | $99$      |    $87$ |\n",
    "\n",
    "This dataset contains 6 grade-values. It is almost immediately clear that storing these in a 1-dimensional array is not ideal:\n",
    "\n",
    "```python\n",
    "# using a 1-dimensional array to store the grades\n",
    ">>> grades = np.array([93, 95, 84, 100, 99, 87])\n",
    "```\n",
    "\n",
    "While no data has been lost, accessing this data using a single index is less-than convenient; we want to be able to specify both the student and the exam when accessing a grade - it is natural to ascribe *two dimensions* to this data. Let's construct a 2D array containing these grades:\n",
    "\n",
    "```python\n",
    "# using a 2-dimensional array to store the grades\n",
    "grades = np.array([[93,  95], \n",
    "                   [84, 100], \n",
    "                   [99,  87]])\n",
    "```\n",
    "\n",
    "NumPy is able to see the repeated structure among the list-of-lists-of-numbers passed to `np.array`, and resolve the two dimensions of data, which we deem the 'student' dimension and the 'exam' dimension, respectively. \n",
    "\n",
    "<div class=\"alert alert-warning\">\n",
    "\n",
    "**Axis vs Dimension**:  \n",
    "\n",
    "Although NumPy does formally recognize the concept of dimensionality precisely in the way that it is discussed here, its documentation refers to an individual dimension of an array as an **axis**. Thus you will see \"axes\" (pronounced \"aks-ēz\") used in place of \"dimensions\", however they mean the same thing.\n",
    "\n",
    "</div>\n",
    "\n",
    "NumPy specifies the row-axis (students) of a 2D array as \"axis-0\" and the column-axis (exams) as axis-1. You must now provide *two* indices, one for each axis (dimension), to uniquely specify an element in this 2D array; the first number specifies an index along axis-0, the second specifies an index along axis-1. The zero-based indexing schema that we reviewed earlier applies to each axis of the ND-array:\n",
    "\n",
    "```                                                    \n",
    "                                                  -- axis-1 -> \n",
    "                                                    -2  -1    \n",
    "                                                     0   1 \n",
    "                                        |          +---+---+  \n",
    "                                        |    -3, 0 |93 | 95| \n",
    "                                        |          +---+---+\n",
    "                                      axis-0 -2, 1 |84 |100|  \n",
    "                                        |          +---+---+\n",
    "                                        |    -1, 2 |99 | 87|\n",
    "                                        V          +---+---+\n",
    "```\n",
    "\n",
    "\n",
    "\n",
    "### Integer Indexing\n",
    "Thus, if we want to access Brad's (item-1 along axis-0) score for Exam  1 (item-0 along axis-1) we simply specify:\n",
    "\n",
    "```python\n",
    "# providing two numbers to access an element\n",
    "# in a 2D-array\n",
    ">>> grades[1, 0]  # Brad's score on Exam 1\n",
    "84\n",
    "\n",
    "# negative indices work as with lists/tuples/strings\n",
    ">>> grades[-2, 0]  # Brad's score on Exam 1\n",
    "84\n",
    "```\n",
    "\n",
    "### Slice Indexing\n",
    "We can also uses *slices* to access subsequences of our data. Suppose we want the scores of all the students for Exam 2. We can slice from 0 through 3 along axis-0 (refer to the indexing diagram in the previous section) to include all the students, and specify index 1 on axis-1 to select Exam 2:\n",
    "\n",
    "```python\n",
    ">>> grades[0:3, 1]  # Exam 2 scores for all students\n",
    "array([ 95, 100,  87])\n",
    "```\n",
    "As with Python sequences, you can specify an \"empty\" slice to include all possible entries along an axis, by default: `grades[:, 1]` is equivalent to `grades[0:3, 1]`, in this instance. More generally, withholding either the 'start' or 'stop' value in a slice will result in the use smallest or largest valid index, respectively:  \n",
    "```python\n",
    ">>> grades[1:, 1]  # equivalent to `grades[1:3, 1]\n",
    "array([ 100,  87])\n",
    "\n",
    ">>> grades[:, :1]  # equivalent to `grades[0:3, 0:1]\n",
    "array([[93],\n",
    "       [84],\n",
    "       [99]])\n",
    "```\n",
    "The output of `grades[:, :1]` might look somewhat funny. Because the axis-1 slice only includes one column of numbers, the shape of the resulting array is (3, 1). 0 is thus only valid (non-negative) index for axis-1, since there is only one column to specify in the array.  \n",
    "\n",
    "You can also supply a \"step\" value to the slice. `grades[::-1, :]` will returns the array of grades with the student-axis flipped (reverse alphabetical order).\n",
    "\n",
    "### Negative Indices\n",
    "As indicated above, negative indices are valid too and are quite useful. If we want to access the scores of the latest exam for all of the students, you can specify:\n",
    "\n",
    "```python\n",
    "# using a negative index and a slice\n",
    ">>> grades[:, -1]  # Latest exam scores (Exam 2), for all students\n",
    "```\n",
    "Note the value of using the negative index is that it will always provide you with the latest exam score - you need not check how many exams the students have taken.\n",
    "\n",
    "### Supplying Fewer Indices Than Dimensions \n",
    "What happens if we only supply one index to our array? It may be surprising that `grades[0]` does not throw an error since we are specifying only one index to access data from a 2-dimensional array. Instead, NumPy it will return all of the exam scores for student-0 (Ashley):\n",
    "\n",
    "```python\n",
    ">>> grades[0] \n",
    "array([ 93, 95])\n",
    "```\n",
    "This is because NumPy will automatically insert trailing-slices for you if you don't provide as many indices as there are dimensions for your array. `grades[0]` was treated as `grades[0, :]`.\n",
    "\n",
    "<div class=\"alert alert-info\"> \n",
    "Suppose you have an $N$-dimensional array, and only provide $j$ indices for the array; NumPy will automatically insert $N-j$ trailing slices for you. In the case that $N=5$ and $j=3$, `d5_array[0, 0, 0]` is treated as  `d5_array[0, 0, 0, :, :]`\n",
    "</div>\n",
    "\n",
    "\n",
    "Thus far, we have discussed some rules for accessing data in arrays, all of which fall into the category that is designated [\"basic indexing\"](https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html#basic-slicing-and-indexing) by the NumPy documentation. We will discuss the details of basic indexing and of [\"advanced indexing\"](https://docs.scipy.org/doc/numpy-1.13.0/reference/arrays.indexing.html#advanced-indexing), in full, in a later section. Note, however, that all of the indexing/slicing reviewed here produces a \"view\" of the original array. That is, *no data is copied* when you index into an array using integer indices and/or slices. Recall that slicing lists and tuples *do* produce copies of the data.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-warning\">\n",
    "\n",
    "**FYI**: \n",
    "\n",
    "Keeping track of the meaning of an array's various dimensions can quickly become unwieldy when working with real datasets. [xarray](http://xarray.pydata.org/en/stable/) is a Python library that provides functionality comparable to NumPy, but allows users provide *explicit labels* for an array's dimensions; that is, you can *name* each dimension. Using an `xarray` to select Brad's scores could look like `grades.sel(student='Brad')`, for instance. This is a valuable library to look into at your leisure.\n",
    "\n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## N-dimensional Arrays\n",
    "Let's build up some intuition for arrays with a dimensionality higher than 2. The following code creates a 3-dimensional array:\n",
    "```python\n",
    "d3_array = np.array([[[0, 1],\n",
    "                      [2, 3]],\n",
    "                     [[4, 5],\n",
    "                      [6, 7]]])\n",
    "```\n",
    "You can think of axis-0 denoting which of the 2x2 \"sheets\" to select from. Then axis-1 specifies the row along the sheets, and axis-2 the column within the row:\n",
    "\n",
    "**Depicting the layout of a 3D array**\n",
    "```\n",
    "                                           sheet 0:\n",
    "                                                  [0, 1]\n",
    "                                                  [2, 3]\n",
    "\n",
    "                                           sheet 1:\n",
    "                                                  [4, 5]\n",
    "                                                  [6, 7]\n",
    "                                                  \n",
    "\n",
    "\n",
    "                                        |       -- axis-2 ->\n",
    "                                        |    |    \n",
    "                                        |  axis-1 [0, 1]\n",
    "                                        |    |    [2, 3]\n",
    "                                        |    V\n",
    "                                     axis-0     \n",
    "                                        |      -- axis-2 ->\n",
    "                                        |    |    \n",
    "                                        |  axis-1 [4, 5]\n",
    "                                        |    |    [6, 7]\n",
    "                                        V    V\n",
    "\n",
    "```\n",
    "\n",
    "Thus `d3_array[0, 1, 0]` specifies the element residing in sheet-0, at row-1 and column-0:\n",
    "```python\n",
    "# retrieving a single element from a 3D-array\n",
    ">>> d3_array[0, 1, 0]\n",
    "2\n",
    "```\n",
    "\n",
    "`d3_array[:, 0, 0]` specifies the elements in row-0 and column-0 of **both** sheets:\n",
    "```python\n",
    "# retrieving a 1D sub-array from a 3D-array\n",
    ">>> d3_array[:, 0, 0]\n",
    "array([0, 4])\n",
    "```\n",
    "`d3_array[1]`, which recall is shorthand for `d3_array[1, :, :]`, selects both rows and both columns of sheet-1:\n",
    "```python\n",
    "# retrieving a 2D sub-array from a 3D-array\n",
    ">>> d3_array[1]\n",
    "array([[4, 5],\n",
    "       [6, 7]])\n",
    "```\n",
    "\n",
    "In four dimensions, one can think of \"*stacks* of sheets with rows and columns\" where axis-0 selects the stack of sheets you are working with, axis-1 chooses the sheet, axis-2 chooses the row, and axis-3 chooses the column. Extrapolating to higher dimensions (\"collections of stacks of sheets ...\") continues in the same tedious fashion.  \n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Zero-dimensional Arrays\n",
    "A zero dimensional array is simply a single number (a.k.a a scalar value):\n",
    "```python\n",
    "# creating a 0-dimensional array\n",
    ">>> x = np.array(15.2)\n",
    "```\n",
    "\n",
    "This is *not* equivalent to a length-1 1D-array: `np.array([15.2])`. According to our definition of dimensionality, *zero* numbers are required to index into a 0-D array as it is unnecessary to provide an identifier for a standalone number. Thus you cannot index into a 0-D array.\n",
    "```python\n",
    "# you cannot index into a 0-D array\n",
    ">>> x[0]\n",
    "---------------------------------------------------------------------------\n",
    "IndexError                                Traceback (most recent call last)\n",
    "<ipython-input-10-2f755f117ac9> in <module>()\n",
    "----> 1 x[0]\n",
    "\n",
    "IndexError: too many indices for array\n",
    "    \n",
    "```\n",
    "\n",
    "You must use the syntax `arr.item()` to retrieve the numerical entry from a 0D array:\n",
    "```python\n",
    ">>> x.item()\n",
    "15.2\n",
    "```\n",
    "\n",
    "Zero-dimensional arrays do not show up in real applications very often. They are, however, important from the point of view of NumPy being self-consistent in how it treates dimensionality in its arrays, and it is important that you are at least exposed to a 0D array and understand its nuances."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-info\">\n",
    "\n",
    "**Takeaway**: \n",
    "\n",
    "Although accessing data along varying dimensions is ultimately all a matter of judicious bookkeeping (you *could* access all of this data from a 1-dimensional array, after all), NumPy's ability to provide users with an interface for accessing data along dimensions is incredibly useful. It affords us an ability to impose intuitive, abstract structure to our data. \n",
    "\n",
    "</div> "
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
