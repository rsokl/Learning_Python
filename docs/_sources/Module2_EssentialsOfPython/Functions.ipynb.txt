{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Basics of Functions\n",
    "<div class=\"alert alert-warning\">\n",
    "\n",
    "**Note**: \n",
    "\n",
    "There are reading-comprehension exercises included throughout the text. These are meant to help you put your reading to practice. Solutions for the exercises are included at the bottom of this page.\n",
    "</div>\n",
    "\n",
    "Defining a function allows you to encapsulate a segment of code, specifying the information that enters and leaves the code. You can make use of this \"code-capsule\" repeatedly and in many different contexts. For example, suppose you want to count how many vowels are in a string. The following defines a function that accomplishes this:\n",
    "\n",
    "```python\n",
    "def count_vowels(in_string):\n",
    "    \"\"\" Returns the number of vowels contained in `in_string`\"\"\"\n",
    "    num_vowels = 0\n",
    "    vowels = \"aeiouAEIOU\"\n",
    "    \n",
    "    for char in in_string:\n",
    "        if char in vowels:\n",
    "            num_vowels += 1  # equivalent to num_vowels = num_vowels + 1\n",
    "    return num_vowels\n",
    "```\n",
    "\n",
    "Executing this code will define the *function* `count_vowels`. This function expects to be passed one object, represented by `in_string`, as an *input argument*, and it will *return* the number of vowels stored in that object. Invoking `count_vowels`, passing it an input object, is referred to as *calling* the function:\n",
    "\n",
    "```python\n",
    ">>> count_vowels(\"Hi my name is Ryan\")\n",
    "5\n",
    "```\n",
    "\n",
    "The great thing about this is that it can be used over and over!\n",
    "\n",
    "```python\n",
    ">>> count_vowels(\"Apple\")\n",
    "2\n",
    "\n",
    ">>> count_vowels(\"envelope\")\n",
    "4\n",
    "```\n",
    "\n",
    "In this section, we will learn about the syntax for defining and calling functions in Python"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-info\">\n",
    "\n",
    "**Definition**: \n",
    "\n",
    "A Python **function** is an object that encapsulates code. *Calling* the function will execute the encapsulated code and *return* an object. A function can be defined so that it accepts *arguments*, which are objects that are to be passed to the encapsulated code.  \n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The `def` Statement\n",
    "Similar to `if`, `else`, and `for`, the `def` statement is reserved by the Python language to signify the definition of functions (and a few other things that we'll cover later). The following is the general syntax for defining a Python function:\n",
    "\n",
    "```\n",
    "def <function name>(<function signature>):\n",
    "    \"\"\" documentation string \"\"\"\n",
    "    <encapsulated code>\n",
    "    return <object>\n",
    "```\n",
    "\n",
    "- `<function name>` can be any valid variable name, and *must* be followed by parentheses and then a colon.\n",
    "- `<function signature>` specifies the input arguments to the function, and may be left blank (if the function does not accept any arguments).\n",
    "- The documentation string (commonly referred to as a *docstring*) may span multiple lines, and should indicate what the function's purpose is. It is optional.\n",
    "- `<encapsulated code>` can consist of general Python code, and is demarcated by being indented relative to the `def` statement.\n",
    "- `return` is used to indicate what object should be returned, whenever the function is called.\n",
    " \n",
    "The `return` statement is also reserved by Python. It denotes the end of a function - if reached, a `return` statement immediately concludes the execution of the function and returns the specified value. \n",
    "\n",
    "Note that, like an if-statement and a for-loop, the content of a function is indicated by indentation:\n",
    "***\n",
    "```python\n",
    "# wrong indentation\n",
    "def bad_func1():\n",
    "x = 1\n",
    "    return x\n",
    "```\n",
    "***\n",
    "```python\n",
    "# wrong indentation\n",
    "def bad_func2():\n",
    "    x = 1\n",
    "return x\n",
    "```\n",
    "***\n",
    "```python\n",
    "# missing colon\n",
    "def bad_func3()\n",
    "    x = 1\n",
    "    return x\n",
    "```\n",
    "***\n",
    "```python\n",
    "# missing parenthesis\n",
    "def bad_func4:\n",
    "    x = 1\n",
    "    return x\n",
    "```\n",
    "\n",
    "***\n",
    "```python\n",
    "# this is ok\n",
    "def ok_func():\n",
    "    x = 1\n",
    "    return x\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***\n",
    "\n",
    "**Reading Comprehension: Writing a Basic Function**\n",
    "Write a function named `count_even`. It should accept one input argument, named `numbers`, which will be an iterable containing integers. Have the function return the number of even-valued integers contained in the list. Include a reasonable docstring.\n",
    "\n",
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The `return` Statement\n",
    "In general, any Python object can follow a function's `return` statement. Furthermore, an **empty** `return` statement can be specified, or the **return** statement of a function can be omitted altogether. In both of these cases, *the function will return the `None` object*.\n",
    "\n",
    "```python\n",
    "# this function returns `None`\n",
    "# an \"empty\" return statement\n",
    "def f():\n",
    "    x = 1\n",
    "    return\n",
    "```\n",
    "\n",
    "```python\n",
    "# this function returns `None`\n",
    "# return statement is omitted\n",
    "def f():\n",
    "    x = 1\n",
    "```\n",
    "\n",
    "<div class=\"alert alert-warning\">\n",
    "\n",
    "**Warning!** \n",
    "\n",
    "Take care to not *mistakenly* omit a return statement or leave it blank. You will still be able to call your function, but it will return `None` no matter what!\n",
    "</div>\n",
    "\n",
    "A function also need not have any additional code beyond its return statement. For example, we can make use of `sum` and a generator comprehension (see the previous section of this module) to shorten our `count_vowels` function:\n",
    "\n",
    "```python\n",
    "# the returned object of a function can be specified straight-away\n",
    "def count_vowels(in_string): \n",
    "    \"\"\" Returns the number of vowels contained in `in_string`\"\"\"\n",
    "    return sum(1 for char in in_string if char in \"aeiouAEIOU\")\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-warning\">\n",
    "\n",
    "**Note**: \n",
    "\n",
    "All Python functions return *something*. Even the built-in `print` function returns `None` after it prints to standard-output!  \n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Multiple `return` Statements\n",
    "You can specify more than one `return` statement within a function. This can be useful for handling edge-cases or optimizations in your code. Suppose you want your function to compute $e^{x}$, using a [Taylor series](https://en.wikipedia.org/wiki/Taylor_series#Exponential_function) approximation. The function should immediately return `1.0` in the case that $x = 0$:\n",
    "\n",
    "```python\n",
    "def compute_exp(x):\n",
    "    \"\"\" Use a Taylor Series to compute e^x \"\"\"\n",
    "    if x == 0:\n",
    "        return 1.0\n",
    "\n",
    "    from math import factorial\n",
    "    return sum(x**n / factorial(n) for n in range(100))\n",
    "```\n",
    "\n",
    "If `x==0` is `True`, then the first `return` statement is reached. `1.0` will be returned and the function will be \"exited\" immediately, without ever reaching the code following it."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Inline Functions\n",
    "Functions can be defined in-line, as a single return statement:\n",
    "\n",
    "```python\n",
    "def add_2(x):\n",
    "    return x + 2\n",
    "```\n",
    "\n",
    "can be rewritten as:\n",
    "\n",
    "```python\n",
    "def add_2(x): return x + 2\n",
    "```\n",
    "\n",
    "This should be used sparingly - only for exceedingly simple functions that can be easily understood without docstrings."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Arguments\n",
    "A sequence of comma-separated variable names can specified in the function signature to indicated *positional* arguments for the function. For example, the following specifies `x`, `lower`, and `upper` as input arguments to a function, `is_bounded`:\n",
    "\n",
    "```python\n",
    "def is_bounded(x, lower, upper):\n",
    "    return lower <= x <= upper\n",
    "```\n",
    "\n",
    "This function can then be passed its arguments in several way:\n",
    "\n",
    "### Specifying Arguments by Position\n",
    "The objects passed to `is_bounded` will be assigned to its input variables based on their positions. That is, `is_bounded(3, 2, 4)` will assign `x=3`, `lower=2`, and `upper=4`, in accordance with the positional ordering of the function's input arguments:\n",
    "\n",
    "```python\n",
    "# evaluate: 2 <= 3 <= 4\n",
    "# specifying inputs based on position\n",
    ">>> is_bounded(3, 2, 4)\n",
    "True\n",
    "```\n",
    "\n",
    "Feeding a function too few or too many arguments will raise a `TypeError`\n",
    "```python\n",
    "# too few inputs: raises error\n",
    "is_bounded(3)\n",
    "\n",
    "# too many inputs: raises error\n",
    "is_bounded(1, 2, 3, 4)\n",
    "```\n",
    "\n",
    "### Specifying Arguments by Name\n",
    "You can provide explicit names when specifying the inputs to a function, in which case ordering does not matter. This is very nice for writing clear and flexible code:\n",
    "```python\n",
    "# evaluate: 2 <= 3 <= 4\n",
    "# specify inputs using explicit input names\n",
    ">>> is_bounded(lower=2, x=3, upper=4)\n",
    "True\n",
    "```\n",
    "\n",
    "You can mix-and-match positional and named input by using position-based inputs first:\n",
    "\n",
    "```python\n",
    "# evaluate: 2 <= 3 <= 4\n",
    "# `x` is specified based on position\n",
    "# `lower` and `upper` are specified by name\n",
    ">>> is_bounded(3, upper=4, lower=2)\n",
    "True\n",
    "```\n",
    "\n",
    "Note that if you provide a named input, all the inputs following it must also be named:\n",
    "\n",
    "```python\n",
    "# positional arguments cannot follow named arguments\n",
    ">>> is_bounded(3, lower=2, 4)\n",
    "# error!\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Default-Valued Arguments\n",
    "You can specify default values for input arguments to a function. Their default values are utilized if a user does not specify these inputs when calling the function. Recall our `count_vowels` function. Suppose we want the ability to include \"y\" as a vowel. We know, however, that people will typically want to exclude \"y\" from their vowels, so we can exclude \"y\" by default:\n",
    "\n",
    "```python\n",
    "def count_vowels(in_string, include_y=False): \n",
    "    \"\"\" Returns the number of vowels contained in `in_string`\"\"\"\n",
    "    vowels = \"aeiouAEIOU\"\n",
    "    if include_y:\n",
    "        vowels += \"yY\"  # add \"y\" to vowels  \n",
    "    return sum(1 for char in in_string if char in vowels)\n",
    "```\n",
    "\n",
    "Now, if only `in_string` is specified when calling `count_vowels`, `include_y` will be passed the value `False` by default:\n",
    "\n",
    "```python\n",
    "# using the default value: exclude y from vowels\n",
    ">>> count_vowels(\"Happy\")\n",
    "1\n",
    "```\n",
    "\n",
    "This default value can be overridden:\n",
    "```python\n",
    "# overriding the default value: include y as a vowel\n",
    ">>> count_vowels(\"Happy\", True)\n",
    "2\n",
    "\n",
    "# you can still specify inputs by name\n",
    ">>> count_vowels(include_y=True, in_string=\"Happy\")\n",
    "2\n",
    "```\n",
    "\n",
    "Default-valued input arguments must come after all positional input arguments in the function signature:\n",
    "```python\n",
    "# this is ok\n",
    "def f(x, y, z, count=1, upper=2):\n",
    "    return None\n",
    "```\n",
    "\n",
    "```python\n",
    "# this will raise a syntax error\n",
    "def f(x, y, count=1, upper=2, z):\n",
    "    return None\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***\n",
    "\n",
    "**Reading Comprehension: Functions and Arguments**\n",
    "\n",
    "Write a function, `max_or_min`, which accepts two positional arguments, `x` and `y` (which will hold numerical values), and a `mode` variable that has the default value `\"max\"`. \n",
    "\n",
    "The function should return `min(x, y)` or `max(x, y)` according to the `mode`. Have the function return `None` if `mode` is neither `\"max\"` nor `\"min\"`. \n",
    "\n",
    "Include a descriptive doc-string.\n",
    "\n",
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Accommodating an Arbitrary Number of Positional Arguments\n",
    "Python provides us with a syntax for defining a function, which can be called with an arbitrary number of positional arguments. This is signaled by the syntax `def f(*<var_name>)`.\n",
    "\n",
    "```python\n",
    "# The * symbol indicates that an arbitrary number of\n",
    "# arguments can be fed to `f` when calling it.\n",
    "def f(*args):\n",
    "    #  All arguments passed to `f` will be \"packed\" into a \n",
    "    #  tuple that is assigned to the variable `args`.\n",
    "    # `f()`  will assign `args = tuple()`\n",
    "    # `f(x, y, ...)` will assign `args = (x, y, ...)`\n",
    "    return args\n",
    "```\n",
    "\n",
    "Because it cannot be foreseen how many arguments will be passed to `f`, all of the objects that are passed to it will be *packed into a tuple*, which is then assigned to the variable `args`:\n",
    "\n",
    "```python\n",
    ">>> f()            # pass zero arguments to `f`\n",
    "()\n",
    "\n",
    ">>> f(1)           # pass one argument to `f`\n",
    "(1,)\n",
    "\n",
    ">>> f((0, 1), True, \"cow\")  # pass three arguments to `f`\n",
    "((0, 1), True, \"cow\")\n",
    "```\n",
    "\n",
    "This syntax can be combined with positional arguments and default arguments. Any variables specified after a packed variable *must be called by name*:\n",
    "```python\n",
    "def f(x, *seq, y):\n",
    "    print(\"x is: \", x)\n",
    "    print(\"seq is: \", seq)\n",
    "    print(\"y is: \", y)\n",
    "    return None\n",
    "\n",
    ">>> f(1, 2, 3, 4, y=5)  # `y` must be specified by name\n",
    "x   is:  1\n",
    "seq is:  (2, 3, 4)\n",
    "y   is:  5\n",
    "```\n",
    "```python\n",
    ">>> f(\"cat\", y=\"dog\")  # no additional positional arguments are passed\n",
    "x   is:  \"cat\"\n",
    "seq is:  ()\n",
    "y   is:  \"dog\"\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***\n",
    "\n",
    "**Reading Comprehension: Arbitrary Arguments**\n",
    "\n",
    "Write a function named `mean`, which accepts and arbitrary number of numerical arguments, and computes the mean of all of the values passed to the function. Thus `mean(1, 2, 3)` should return $\\frac{1 + 2 + 3}{3} = 2.0$ \n",
    "\n",
    "This function should return `0.` if no arguments are passed to it. Be sure to test your function, and include a docstring.\n",
    "\n",
    "***"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Functions are Objects\n",
    "Once defined, a function behaves like any other Python object, like a list or string or integer. You can assign a variable to a function-object:\n",
    "```python\n",
    ">>> var = count_vowels  # `var` now references the function `count_vowels`\n",
    ">>> var(\"Hello\")        # you can now \"call\" `var`\n",
    "2\n",
    "```\n",
    "\n",
    "You can store functions in a list:\n",
    "```python\n",
    "my_list = [count_vowels, print]\n",
    "\n",
    "for func in my_list:\n",
    "    func(\"hello\") \n",
    "```\n",
    "\n",
    "You can also call functions anywhere, and their return-value will be returned in-place:\n",
    "```python\n",
    "if count_vowels(\"pillow\") > 1:\n",
    "    print(\"that's a lot of vowels!\")\n",
    "```\n",
    "\n",
    "And, of course, this works within comprehension expressions as well:\n",
    "```python\n",
    ">>> sum(count_vowels(word, include_y=True) for word in [\"hi\", \"bye\", \"guy\", \"sigh\"])\n",
    "6\n",
    "```\n",
    "\n",
    "\"Printing\" a function isn't very revealing. It simply tells you the memory address where the function-object is stored:\n",
    "```python\n",
    ">>> print(count_vowels)\n",
    "<function count_vowels at 0x000002A32898C6A8>\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "***\n",
    "\n",
    "## Reading Comprehension Exercise Solutions:\n",
    "**Writing a Basic Function: Solution**\n",
    "\n",
    "```python\n",
    "def count_even(numbers):\n",
    "    \"\"\" Counts the number of even integers in an iterable\"\"\"\n",
    "    total_even = 0\n",
    "    for num in numbers:\n",
    "        if num % 2 == 0:\n",
    "            total += 1\n",
    "    return total\n",
    "```\n",
    "or, using a generator comprehension:\n",
    "\n",
    "```python\n",
    "def count_even(numbers):\n",
    "    \"\"\" Counts the number of even integers in an iterable\"\"\"\n",
    "    return sum(1 for num in numbers if num % 2 == 0)\n",
    "```\n",
    "\n",
    "**Functions and Arguments: Solution**\n",
    "\n",
    "```python\n",
    "def max_or_min(x, y, mode=\"max\"):\n",
    "    \"\"\" Return either `max(x,y)` or `min(x,y)`,\n",
    "        according to the `mode` argument.\n",
    "        \n",
    "        Parameters\n",
    "        ----------\n",
    "        x : Number\n",
    "   \n",
    "        y : Number\n",
    "   \n",
    "        mode : str\n",
    "           Either 'max' or 'min'\n",
    "        \n",
    "        Returns\n",
    "        -------\n",
    "        The max or min of the two values. `None` is\n",
    "        returned if an invalid mode was specified.\"\"\"\n",
    "    if mode == \"max\":\n",
    "        return max(x, y)\n",
    "    elif mode == \"min\":\n",
    "        return min(x, y)\n",
    "    else:\n",
    "        return None\n",
    "```\n",
    "\n",
    "Note that you can actually have your function raise an \"exception\" (an error) in the case that `mode` wasn't passed a proper value. In fact, that is likely the more appropriate behavior for this function. \n",
    "\n",
    "Such a solution would look like:\n",
    "```python\n",
    "def max_or_min(x, y, mode=\"max\"):\n",
    "    if mode == \"max\":\n",
    "        return max(x, y)\n",
    "    elif mode == \"min\":\n",
    "        return min(x, y)\n",
    "    else:\n",
    "        raise Exception(\"`mode` was passed an invalid value: {}\".format(mode))\n",
    "```\n",
    "\n",
    "**Arbitrary Arguments: Solution**\n",
    "\n",
    "```python\n",
    "def mean(*seq):\n",
    "    \"\"\" Returns the mean of the function's arguments \"\"\"\n",
    "    if len(seq) == 0:\n",
    "        return 0\n",
    "    \n",
    "    total = 0 \n",
    "    for num in seq:\n",
    "        total += num\n",
    "    return total / len(seq)\n",
    "```\n",
    "\n",
    "or, being a bit more fancy :\n",
    "- using the fact that `bool(seq)` is `False` if `seq` is empty\n",
    "- using the inline if-else syntax\n",
    "\n",
    "```python\n",
    "def mean(*seq):\n",
    "    \"\"\" Returns the mean of the function's arguments \"\"\"\n",
    "    return sum(seq) / len(seq) if seq else 0\n",
    "```"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
