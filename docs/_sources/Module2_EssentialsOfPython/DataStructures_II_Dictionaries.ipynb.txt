{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#  Data Structures (Part II): Dictionaries\n",
    "Python's dictionary allows you to store key-value pairs, and then pass the dictionary a key to quickly retrieve its corresponding value. Specifically, you construct the dictionary by specifying one-way mappings from key-objects to value-objects. **Each key must map to exactly one value**, meaning that a key must be unique. \n",
    "\n",
    "Python's dictionary is a shining star among its data structures; it is compact, fast, versatile, and extremely useful:\n",
    "\n",
    "```python\n",
    "# use a dictionary to map groceries to prices: item-name -> price \n",
    ">>> items_to_prices = {\"cheese\": 2.53, \"milk\": 3.40, \"frozen pizza\": 8.01}\n",
    ">>> items_to_prices[\"frozen pizza\"]\n",
    "8.01\n",
    "\n",
    "# keep track of whether or not a 3D coordinate fell into some region in space\n",
    "# map (x, y, z) coordinates to \"is in a region\": (x, y, z) -> True/False\n",
    ">>> point_to_region = {(0.1, 2.2, 3):False, (-10., 0, 4.5):True, (4.3, 1.0, 9.5):False}\n",
    ">>> point_to_region[(-10., 0, 4.5)]\n",
    "True\n",
    "\n",
    "# map student-name to exam scores: name -> scores\n",
    ">>> name_to_scores = {\"Ryan S\":[65, 50, 80], \"Nick S\":[100, 99, 90]}\n",
    ">>> name_to_scores[\"Ryan S\"]\n",
    "[65, 50, 80]\n",
    "```\n",
    "\n",
    " It is important to note outright that the time it takes for dictionary to take a key and retrieve a value *does not depend on the size of the dictionary.* That is the complexity for a dictionary look-up is $\\mathcal{O}(1)$! It accomplishes this by making use of a technique known as [hashing](https://en.wikipedia.org/wiki/Hash_function).\n",
    "\n",
    "\n",
    "We will be discussing the essentials of the dictionary. It is highly recommended that you refer to the official Python documentation for a [complete rundown of all the functions available to the dictionary](https://docs.python.org/3/library/stdtypes.html#dict)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Dictionary Basics\n",
    "### Constructing a dictionary\n",
    "A nice syntax for creating a dictionary is to specify key-value pairs inside \"curly braces\": `{key1:value1, key2:value2, ...}`. As an example, let's construct a dictionary that maps types of foods to \"fruit\" or \"vegetable\". We'll start by mapping \"apple\" to \"fruit\", and \"carrot\" to \"vegetable\"\n",
    "```python\n",
    "# use `{key1:value1, key2:value2, ...} to create a dictionary that maps:\n",
    "#  \"apple\" -> \"fruit\"\n",
    "# \"carrot\" -> \"vegetable\n",
    ">>> fruit_or_veggie = {\"apple\":\"fruit\", \"carrot\":\"vegetable\"} \n",
    "\n",
    "# create an empty dictionary\n",
    ">>> {}\n",
    "{}\n",
    "```\n",
    "You can also use the built-in `dict` constructor to create the dictionary. This can be fed an iterable of sequences of key-value pairs:\n",
    "\n",
    "```python\n",
    "# use `dict` to create a dictionary that maps:\n",
    "#  \"apple\" -> \"fruit\"\n",
    "# \"carrot\" -> \"vegetable\n",
    ">>> fruit_or_veggie = dict([(\"apple\", \"fruit\"), (\"carrot\", \"vegetable\")])\n",
    "\n",
    "# use `dict` to create an empty dictionary:\n",
    ">>> dict()\n",
    "{}\n",
    "```\n",
    "Lastly, Python also supports a dictionary-comprehension syntax, which mirrors the generator/list comprehension syntax covered earlier in this module:\n",
    "\n",
    "```\n",
    "{key:value for key, value in <iterable of key-value pairs> [if bool(<condition>)]}\n",
    "```\n",
    "\n",
    "```python\n",
    "# use the 'dictionary comprehension' syntax to create a dictionary that maps:\n",
    "#  \"apple\" -> \"fruit\"\n",
    "# \"carrot\" -> \"vegetable\n",
    ">>> {k:v for k,v in [(\"apple\", \"fruit\"), (\"carrot\", \"vegetable\")]}\n",
    "{'apple': 'fruit', 'carrot': 'vegetable'}\n",
    "```\n",
    "\n",
    "### Retrieving a value, given a key\n",
    "Now we can use this dictionary to \"look up\" if an item is a fruit or a veggie. Dictionaries support the same square-bracket \"get-item\" syntax as a list/tuple, but here a valid key is used as the index:\n",
    "```python\n",
    "# get the value associated with the key \"apple\"\n",
    ">>> fruit_or_veggie[\"apple\"]\n",
    "\"fruit\"\n",
    "```\n",
    "\n",
    "`KeyError` will be raised if you try to look-up a key that doesn't exist:\n",
    "```python\n",
    "# \"grape\" hasn't been specified as a key\n",
    ">>> fruit_or_veggie[\"grape\"]\n",
    "---------------------------------------------------------------------------\n",
    "KeyError                                  Traceback (most recent call last)\n",
    "<ipython-input-30-74c002a67890> in <module>()\n",
    "----> 1 fruit_or_veggie[\"grape\"]\n",
    "\n",
    "KeyError: 'grape'\n",
    "```\n",
    "\n",
    "### Adding more key-value mappings\n",
    "Once created, a dictionary can have a new key-value pair be \"set\" using `my_dict[new_key] = new_value`:\n",
    "```python\n",
    "# set the mapping \"banana\" -> \"fruit\"\n",
    ">>> fruit_or_veggie[\"banana\"] = \"fruit\"\n",
    ">>> fruit_or_veggie\n",
    "{'apple': 'fruit', 'banana': 'fruit', 'carrot': 'vegetable'}\n",
    "```\n",
    "If the key already exists, the mapping for that key will simply be updated.\n",
    "\n",
    "The `update` function can be used to add multiple key-value pairs at once. This function can be passed another dictionaries, or iterables of key-value sequences\n",
    "```python\n",
    "# adding multiple key-value pairs to the dictionary\n",
    ">>> fruit_or_veggie.update([(\"grape\", \"fruit\"), (\"onion\", \"vegetable\")])\n",
    ">>> fruit_or_veggie\n",
    "{'apple': 'fruit',\n",
    " 'banana': 'fruit',\n",
    " 'carrot': 'vegetable',\n",
    " 'grape': 'fruit',\n",
    " 'onion': 'vegetable'}\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## What Can a Dictionary Store?\n",
    "Although the preceding example only involves a mappings from strings to strings, *the keys and values of a dictionary can be heterogeneous in type*:\n",
    "\n",
    "```python\n",
    "# demonstrates the wide variety of object types that can be used as\n",
    "# keys and values in a dictionary\n",
    ">>> example_dict = {-1:10, \"moo\":True, (1, 2):print, 3.4:\"cow\", False:[]}\n",
    ">>> example_dict[-1]\n",
    "10\n",
    "\n",
    ">>> example_dict[\"moo\"]\n",
    "True\n",
    "\n",
    ">>> example_dict[(1, 2)]\n",
    "<function print>\n",
    "\n",
    ">>> example_dict[3.4]\n",
    "\"cow\"\n",
    "\n",
    ">>> example_dict[False]\n",
    "[]\n",
    "```\n",
    "\n",
    "To be specific, a dictionary's contents are dictated by the following rules:\n",
    "\n",
    "- A dictionary *key* must be an *immutable* object (more precisely, it must be [hashable](https://docs.python.org/3/glossary.html#term-hashable); don't worry about this detail). \n",
    "- A dictionary *value* can be any object (even the dictionary itself! Try this, it's cool!)\n",
    "\n",
    "<div class=\"alert alert-warning\">\n",
    "\n",
    "**Recall**: \n",
    "\n",
    "A mutable object can be changed after it is created. An immutable object cannot be changed.\n",
    "</div>\n",
    "\n",
    "Thus valid keys can be the following types:\n",
    "\n",
    " - numbers (integers, floating-point numbers, complex numbers)\n",
    " - strings\n",
    " - tuples (if the tuple contains anything, it must be other immutable objects)\n",
    " - boolean values\n",
    " - `frozenset` objects\n",
    " \n",
    "Trying to use a mutable object as a key is problematic since that object could be changed *after* it was already used as a key. Thus the dictionary would have to \"detect\" this change and recreate its \"lookup scheme\" for the changed key. Values, on the other hand, can be mutable because the details of a given value-object have no impact on how the dictionary retrieves it.\n",
    " \n",
    "In accordance with this discussion will get a `TypeError` if you try to use a list as a key, since lists are mutable:\n",
    "```python\n",
    "# trying to use a list as a key \n",
    "# this raises an error because lists are mutable\n",
    ">>> bad_dict = {[]:1}\n",
    "---------------------------------------------------------------------------\n",
    "TypeError                                 Traceback (most recent call last)\n",
    "<ipython-input-50-e7cf39509d06> in <module>()\n",
    "----> 1 bad_dict = {[]:1}\n",
    "\n",
    "TypeError: unhashable type: 'list'\n",
    "```\n",
    "\n",
    "<div class=\"alert alert-info\">\n",
    "\n",
    "**Takeaway**: \n",
    "\n",
    "A dictionary key must be an immutable object. A dictionary value can be any object.\n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Inspecting a Dictionary\n",
    "The dictionary provides tooling for inspecting and iterating over its keys and values. We will use the following dictionary for our examples:\n",
    "\n",
    "```python\n",
    ">>> example_dict = {\"key1\":\"value1\", \"key2\":\"value2\", \"key3\":\"value3\"}\n",
    "```\n",
    "\n",
    "**Inspecting a dictionary's keys**\n",
    "\n",
    "The dictionary itself can be used to iterate over its keys:\n",
    "```python\n",
    "# iterating over a dictionary produces its keys\n",
    ">>> [i for i in example_dict]\n",
    "['key1', 'key2', 'key3']\n",
    "```\n",
    "\n",
    "You can also use the dictionary to test for membership among its keys:\n",
    "\n",
    "```python\n",
    "# checking if an object is among a dictionary's keys\n",
    ">>> \"key3\" in example_dict\n",
    "True\n",
    "\n",
    "# you *cannot* use this to check for membership among its valus\n",
    ">>> \"value3\" in example_dict\n",
    "False\n",
    "```\n",
    "`len` counts the number of keys in the dictionary:\n",
    "```python\n",
    ">>> len(example_dict)\n",
    "3\n",
    "```\n",
    "\n",
    "**Inspecting a dictionary's values**\n",
    "\n",
    "`example_dict.values()` can be iterated over to produce that dictionary's values:\n",
    "```python\n",
    "# iterating over a dictionary's values\n",
    ">>> [i for i in example_dict.values()]\n",
    "['value1', 'value2', 'value3']\n",
    "```\n",
    "\n",
    "You can also use this to test for membership among the dictionary's values:\n",
    "\n",
    "```python\n",
    "# checking if an object is among a dictionary's values\n",
    ">>> \"value1\" in example_dict.values()\n",
    "True\n",
    "```\n",
    "\n",
    "**Inspecting a dictionary's key-value pairs**\n",
    "\n",
    "`example_dict.items()` can be iterated over to produce that dictionary's key-value pairs (which are packed into tuples):\n",
    "```python\n",
    "# iterating over a dictionary produces its keys\n",
    ">>> [i for i in example_dict.items()]\n",
    "[('key1', 'value1'), ('key2', 'value2'), ('key3', 'value3')]\n",
    "```\n",
    "\n",
    "You can also use this to test for membership among the dictionary's key-value pairs:\n",
    "\n",
    "```python\n",
    "# checking if a key-value pair exists in a dictionary\n",
    ">>> ('key1', 'value1') in example_dict.items()\n",
    "True\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Time Complexities of the Dictionary's Functions\n",
    "In addition to being flexible and versatile, the dictionary's functions manage to be quite efficient as well. The following is a summary of the time complexities associated with various common operations using a dictionary (according to its implementation in CPython) - note all the $\\mathcal{O}(1)$ operations!\n",
    "\n",
    "Let `example_dict` represent a dictionary with $n$ key-value pair mappings.\n",
    "\n",
    "The following are $\\mathcal{O}(1)$ operations:\n",
    "\n",
    "- Return the number of keys in the dictionary: `len(example_dict)` \n",
    "- Check if the key is in the dictionary, and return the value if it is: `example_dict[key]` \n",
    "- Set a key-value mapping: `example_dict[key] = value` \n",
    "- Check if an object is among the dictionary's keys: `obj in example_dict` \n",
    "- Check if a pair of objects are among the dictionary's key-value pairs: `(obj1, obj2) in example_dict.items()`\n",
    "\n",
    "The following are $\\mathcal{O}(n)$ operations:\n",
    "\n",
    "- Check if an object is among the dictionary's values: `obj in example_dict.values()`\n",
    "- Iterate over the dictionary's keys/values/key-value pairs"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Are Dictionaries Ordered? A Word of Warning\n",
    "Unlike Python's sequences, the dictionary has no inherent ordering... that is, until Python 3.6 came out. \n",
    "\n",
    "Prior to Python 3.6, a dictionary had no ordering associated with it. If you iterated over its keys, values, or key-value pairs, you had no guarantee about the *order* in which these items would be produced. `[i for i in example_dict]` could produce a list of keys with different ordering each time the code was run; you were only guaranteed that the list would contain all of the dictionary's keys: \n",
    "\n",
    "```python\n",
    "# in Python 3.5 and earlier, dictionaries were unordered\n",
    ">>> example_dict = {\"key1\":\"value1\", \"key2\":\"value2\", \"key3\":\"value3\"}\n",
    "\n",
    "# this can produce lists with different orders\n",
    ">>> [i for i in example_dict]\n",
    "[\"key1\", \"key3\", \"key2\"]\n",
    "\n",
    ">>> [i for i in example_dict]\n",
    "[\"key2\", \"key1\", \"key3\"]\n",
    "\n",
    ">>> [i for i in example_dict]\n",
    "[\"key1\", \"key2\", \"key3\"]\n",
    "\n",
    "...\n",
    "```\n",
    "\n",
    "The dictionary was [reimplemented in Python 3.6](https://docs.python.org/3/whatsnew/3.6.html#new-dict-implementation) so that it would consume roughly 25% less memory than before (which is a big deal!). The catch was... this new implementation entails that the dictionary's various iterables will always yield their items according to the order in which they were added to the dictionary. That is, in Python 3.6 and beyond:\n",
    "\n",
    "```python\n",
    "# in Python 3.6 and beyond, dictionaries are ordered\n",
    ">>> example_dict = {\"key1\":\"value1\", \"key2\":\"value2\", \"key3\":\"value3\"}\n",
    "\n",
    "# this will always produce the same result\n",
    ">>> [i for i in example_dict]\n",
    "[\"key1\", \"key2\", \"key3\"]\n",
    "```\n",
    "\n",
    "This is great, right? Wrong! If you write code in Python 3.6 that relies on the fact that dictionaries are ordered, your algorithm will almost certainly produce the wrong results if you run it using Python 3.5 or earlier! Worst of all, it very unlikely that this will raise any error in your code, so the bug will persist silently... this is very tough to catch!\n",
    "\n",
    "**No matter what version of Python you are using, write your code as if the dictionary is unordered!** \n",
    "\n",
    "If you do want to use an ordered dictionary, your code should make use of `collections.OrderedDict`, which behaves like just like the standard dictionary, but is guaranteed to maintain ordering regardless of what version of Python you are using.  \n",
    "\n",
    "```python\n",
    "from collections import OrderedDict\n",
    ">>> ordered = OrderedDict([('key1', 'value1'), ('key2', 'value2'), ('key3', 'value3')])\n",
    "\n",
    "# this will always produce the same result\n",
    ">>> [i for i in ordered]\n",
    "[\"key1\", \"key2\", \"key3\"]\n",
    "```\n",
    "\n",
    "<div class=\"alert alert-info\">\n",
    "\n",
    "**Takeaway**: \n",
    "\n",
    "No matter what version of Python you are using, write your code as if the Python dictionary is unordered. If you do want to use an ordered dictionary, your code should make use of `collections.OrderedDict`.\n",
    "</div>"
   ]
  }
 ],
 "metadata": {
  "anaconda-cloud": {},
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
